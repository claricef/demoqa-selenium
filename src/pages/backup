from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.common.exceptions import ElementClickInterceptedException, TimeoutException, ElementNotInteractableException
from selenium.webdriver import ActionChains
import os

class CadastroEstudantePage:
    URL = "https://demoqa.com/automation-practice-form"

    FIRST_NAME_INPUT = (By.ID, "firstName")
    LAST_NAME_INPUT = (By.ID, "lastName")
    EMAIL_INPUT = (By.ID, "userEmail")
    GENDER_RADIO = (By.XPATH, "//label[contains(text(), '{}')]")
    MOBILE_INPUT = (By.ID, "userNumber")
    DATE_OF_BIRTH_INPUT = (By.ID, "dateOfBirthInput")
    SUBJECTS_INPUT = (By.ID, "subjectsInput")
    HOBBIES_CHECKBOX = (By.XPATH, "//label[contains(text(), '{}')]")
    UPLOAD_PICTURE_INPUT = (By.ID, "uploadPicture")
    CURRENT_ADDRESS_TEXTAREA = (By.ID, "currentAddress")
    STATE_DROPDOWN = (By.XPATH, "//div[text()='Select State']/following::input[1]")
    CITY_DROPDOWN = (By.XPATH, "//div[text()='Select City']/following::input[1]")
    SUBMIT_BUTTON = (By.ID, "submit")

    def __init__(self, driver):
        self.driver = driver

    # --- Helpers ---
    def _wait(self, timeout=10):
        return WebDriverWait(self.driver, timeout)

    def _find(self, locator):
        return self.driver.find_element(*locator)

    def _scroll_into_view(self, elem):
        try:
            elf.driver.execute_script("arguments[0].scrollIntoView({block: 'center'});", elem)
        except Exception:
            pass

    def _hide_common_ads(self):
        # Hide common ad iframes and fixed banners that may intercept clicks
        try:
            self.driver.execute_script(
                "Array.from(document.querySelectorAll('iframe')).forEach(i=>{ if(i.src && i.src.includes('googlesyndication')) i.style.display='none'; }); var e = document.getElementById('fixedban'); if(e) e.style.display='none'; var f = document.querySelector('footer'); if(f) f.style.display='none';"
            )
        except Exception:
            pass

    def _safe_click(self, locator, timeout=10):
        wait = self._wait(timeout)
        self._hide_common_ads()
        elem = wait.until(EC.presence_of_element_located(locator))
        self._scroll_into_view(elem)
        try:
            wait.until(EC.element_to_be_clickable(locator))
            elem.click()
            return
        except Exception:
            pass

        try:
            self.driver.execute_script("arguments[0].click();", elem)
            return
        except Exception:
            pass

        try:
            ActionChains(self.driver).move_to_element(elem).click(elem).perform()
            return
        except Exception:
            raise

    # --- Actions ---
    def abrir_pagina(self):
        self.driver.get(self.URL)

    def preencher_nome(self, nome):
        self._find(self.FIRST_NAME_INPUT).send_keys(nome)

    def preencher_sobrenome(self, sobrenome):
        self._find(self.LAST_NAME_INPUT).send_keys(sobrenome)

    def preencher_email(self, email):
        self._find(self.EMAIL_INPUT).send_keys(email)

    def selecionar_genero(self, genero):
        xpath = self.GENDER_RADIO[1].format(genero)
        self._safe_click((By.XPATH, xpath))

    def preencher_telefone(self, telefone):
        self._find(self.MOBILE_INPUT).send_keys(telefone)

    def preencher_data_nascimento(self, data):
        elem = self._find(self.DATE_OF_BIRTH_INPUT)
        try:
            # Prefer flatpickr API when present (keeps widget state consistent)
            self.driver.execute_script(
                "if(arguments[0] && arguments[0]._flatpickr){arguments[0]._flatpickr.setDate(arguments[1], true);} else {arguments[0].value = arguments[1]; arguments[0].dispatchEvent(new Event('input', {bubbles:true})); arguments[0].dispatchEvent(new Event('change', {bubbles:true}));}",
                elem,
                data,
            )
        except Exception:
            try:
                elem.clear()
                elem.send_keys(data)
            except Exception:
                pass

    def preencher_materias(self, materias):
        elem = self._find(self.SUBJECTS_INPUT)
        elem.clear()
        elem.send_keys(materias)
        elem.send_keys(Keys.ENTER)
        try:
            self._wait(5).until(
                EC.invisibility_of_element_located((By.CSS_SELECTOR, ".subjects-auto-complete__option"))
            )
        except TimeoutException:
            pass

    def selecionar_hobbies(self, hobbies):
        xpath = self.HOBBIES_CHECKBOX[1].format(hobbies)
        self._safe_click((By.XPATH, xpath))

    def fazer_upload_foto(self, caminho_foto):
        file_path = os.path.abspath(caminho_foto)
        self._find(self.UPLOAD_PICTURE_INPUT).send_keys(file_path)

    def preencher_endereco(self, endereco):
        self._find(self.CURRENT_ADDRESS_TEXTAREA).send_keys(endereco)

    def selecionar_estado(self, estado):
        elem_locator = self.STATE_DROPDOWN
        self._safe_click(elem_locator)
        elem = self._find(elem_locator)
        elem.send_keys(estado)
        elem.send_keys(Keys.ENTER)
        try:
            self._wait(5).until(EC.element_to_be_clickable(self.CITY_DROPDOWN))
        except TimeoutException:
            pass

    def selecionar_cidade(self, cidade):
       elem = self._find(self.CITY_DROPDOWN)
       try:
           elem.click()
       except Exception:
           try:
               self.driver.execute_script("arguments[0].click();", elem)
           except Exception:
               pass
       try:
           elem.send_keys(cidade)
           elem.send_keys(Keys.ENTER)
       except Exception:
           try:
               self.driver.execute_script(
                   "arguments[0].focus(); arguments[0].value = arguments[1]; arguments[0].dispatchEvent(new Event('change', {bubbles:true}));",
                   elem,
                   cidade,
               )
           except Exception:
               pass

    def clicar_botao_enviar(self):
        self._safe_click(self.SUBMIT_BUTTON)